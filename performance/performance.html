<!DOCTYPE html>
<html>
<head>
	<title>Performance optimization</title>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<link href="../assets/css/base.css" rel="stylesheet" type="text/css" />
</head>
<body>
	<header>
		<img class="epam-logo" src="../assets/img/logo.png"/>
		<h1>Performance optimization</h1>
	</header>

<!-- ================== Slides ================== -->
	<textarea id="source">


class: center, middle

.title[
Front-end training
# Performance optimization
]


---


layout: true

# Constructing the Object Model

Before the browser can render the page it needs to construct the DOM and CSSOM trees. As a result, we need to ensure that we deliver both the HTML and CSS to the browser as quickly as possible.


---


### Simple DOM example:

``` html 
	<html>
		<head>
			<meta name="viewport" content="width=device-width,initial-scale=1.0">
			<link href="style.css" rel="stylesheet">
			<title>Critical Path</title>
		</head>
		<body>
			<p>Hello <span>web performance</span> students!</p>
			<div><img src="awesome-photo.jpg"></div>
		</body>
	</html>
```


---


.img-wrap-80[![DOM example screenshot](../assets/img/performance-optimization-simple-dom-example.png)]


---


layout: false 

# Render-tree construction, Layout, and Paint

### All the steps the browser went through:

<ol>
	<li>Process HTML markup and build the DOM tree.</li>
	<li>Process CSS markup and build the CSSOM tree.</li>
	<li>Combine the DOM and CSSOM into a render tree.</li>
	<li>Run layout on the render tree to compute geometry of each node.</li>
	<li>Paint the individual nodes to the screen.</li>
</ol>



---

layout: true

# Render Blocking CSS


---


CSS is a render blocking resource, get it down to the client as soon and as quickly as possible to optimize the time to first render!


.columns[.col-50[
	.center[With CSS:]
	.img-wrap-60[![NYT with css](../assets/img/performance-optimization-css-render-blocking-with-css.png)]
].col-50[
	.center[Without CSS:]
	.img-wrap-60[![NYT without css](../assets/img/performance-optimization-css-render-blocking-without-css.png)]
]]


---


### Use CSS media queries for responsiveness!

CSS “media types” and “media queries” allow us to address these use-cases:

``` html
	<link href="style.css"    rel="stylesheet">
	<link href="style.css"    rel="stylesheet" media="screen">
	<link href="portrait.css" rel="stylesheet" media="orientation:portrait">
	<link href="print.css"    rel="stylesheet" media="print">
```

---

layout: false

# Adding Interactivity with JavaScript

JavaScript allows us to modify just about every aspect of the page: content, styling, and its behavior to user interactions.

--

However, there is a big performance caveat lurking underneath. JavaScript affords us a lot of power, but it also creates a lot of additional limitations on how and when the page is rendered. If we move the script above the span element, you’ll notice that the script will fail and complain that it cannot find a reference to any span elements in the document.

```javascript
	getElementsByTagName(‘span’); // --> null
```

--

### To add interactivity use this hacks:

- Parser Blocking
- Asynchronous JavaScript


---


# Measuring the Critical Rendering Path with Navigation Timing

You can't optimize what you can't measure. Thankfully, the Navigation Timing API gives us all the necessary tools to measure each step of the critical rendering path!

.img-wrap-60[![Dom timing](../assets/img/performance-optimization-dom-navtiming.png)]

[Example](./assets/critical-path-measure.html)


---

layout: true

# Analyzing Critical Rendering Path Performance

---

### The Hello World experience

```html
	<html>
		<head>
			<meta name="viewport" content="width=device-width,initial-scale=1.0">
			<title>Critical Path: No Style</title>
		</head>
		<body>
			<p>Hello <span>web performance</span> students!</p>
			<div><img src="awesome-photo.jpg"></div>
		</body>
	</html>
```

.img-wrap-100[![Dom timing](../assets/img/performance-optimization-waterfall-dom.png)]

---

### Adding JavaScript and CSS into the mix

```html
	<html>
		<head>
			<title>Critical Path: Measure Script</title>
			<meta name="viewport" content="width=device-width,initial-scale=1.0">
			<link href="style.css" rel="stylesheet">
		</head>
		<body onload="measureCRP()">
			<p>Hello <span>web performance</span> students!</p>
			<div><img src="awesome-photo.jpg"></div>
			<script src="timing.js"></script>
		</body>
	</html>
```
.img-wrap-100[![Dom timing](../assets/img/performance-optimization-waterfall-dom-after.png)]


---


layout: false

# Optimizing the Critical Rendering Path

### The general sequence of steps to optimize the critical rendering path is:

<ol>
	<li>Analyze and characterize your critical path: number of resources, bytes, length.</li>
	<li>Minimize number of critical resources: eliminate them, defer their download, mark them as async, etc.</li>
	<li>Optimize the order in which the remaining critical resources are loaded: you want to download all critical assets as early as possible to shorten the critical path length.</li>
	<li>Optimize the number of critical bytes to reduce the download time (number of roundtrips).</li>
</ol>


---


# PageSpeed Rules and Recommendations
</textarea>
<!-- ================== End of Slides ================== -->

	<script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
	<script type="text/javascript">remark.create({highlightStyle: 'github'});</script>
</body>
</html>
